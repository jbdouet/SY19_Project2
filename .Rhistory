theta<-c(mu, sigma, pi)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err <0.01){
print(it)
return(theta)
}
it = it+1
}
}
EM(x,mu,sigma,pi)
a <- 2
mu <- 0
sigma <- 1
pi <- 0.4 # proportion de la loi normale dans le mélange
n <- 100
EM <- function(x,mu,sigma,pi){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
n <- length(x)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err <0.01){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
EM(x,mu,sigma,pi)
mu_init <- 0
sigma_init <- 0
pi_init <- 0
EM(x,mu_init,sigma_init,pi_init)
EM <- function(x,mu,sigma,pi){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
n <- length(x)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.01){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0
pi_init <- 0
EM(x,mu_init,sigma_init,pi_init)
EM <- function(x,mu,sigma,pi){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
n <- length(x)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
#if (err<0.01){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0
pi_init <- 0
EM(x,mu_init,sigma_init,pi_init)
pi_init <- 1
EM(x,mu_init,sigma_init,pi_init)
EM <- function(x,mu,sigma,pi){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
print(Q_Value)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.01){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0
pi_init <- 1
EM(x,mu_init,sigma_init,pi_init)
a <- 2
EM(x,mu_init,sigma_init,pi_init,a)
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
print(Q_Value)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.01){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0
pi_init <- 1
a <- 2
EM(x,mu_init,sigma_init,pi_init,a)
Q(x,mu_init,sigma_init,pi_init,a)
pi_init <- 0.5
a <- 2
EM(x,mu_init,sigma_init,pi_init,a)
Q(x,mu_init,sigma_init,pi_init,a)
pi_init <- 0.7
a <- 2
Q(x,mu_init,sigma_init,pi_init,a)
mu_init <- 0
sigma_init <- 0
pi_init <- 0.7
Q(x,mu_init,sigma_init,pi_init,a)
pi_init <- 0.7
Q(x,mu_init,sigma_init,pi_init,a)
pi_init <- 0.2
Q(x,mu_init,sigma_init,pi_init,a)
EM(x,mu_init,sigma_init,pi_init,a)
a <- 20
Q(x,mu_init,sigma_init,pi_init,a)
Q(x,mu_init,sigma_init,pi_init,a)
Q <- function (x,mu,sigma,pi,a){
phi <-dnorm(x, mean = mu, sd = sigma, log = FALSE)
print (phi)
res <- (pi * phi)/ (phi*pi + (1-pi)*1/(2*a))
return(res)
}
Q(x,mu_init,sigma_init,pi_init,a)
x
x<- final_sample
sigma_init <- 0.1
pi_init <- 0.2
Q(x,mu_init,sigma_init,pi_init,a)
EM(x,mu_init,sigma_init,pi_init,a)
Q <- function (x,mu,sigma,pi,a){
phi <-dnorm(x, mean = mu, sd = sigma, log = FALSE)
res <- (pi * phi)/ (phi*pi + (1-pi)*1/(2*a))
return(res)
}
Q_Value <- Q (x,mu,sigma,pi,a)
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.00001){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0.1
pi_init <- 0.2
a <- 20
EM(x,mu_init,sigma_init,pi_init,a)
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
print(Q_Value)
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
print(theta)
tvec = c(tmu, tsigma,tpi)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
#if (err<0.00001){
#  print(it)
#  return(theta)
#}
it = it+1
}
}
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
print(Q_Value)
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
mu <- mu_update
sigma <- sigma_update
pi <- pi_update
theta<-c(mu, sigma, pi)
print(theta)
tvec = c(tmu, tsigma,tpi)
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.00001){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0.1
pi_init <- 0.2
a <- 20
EM(x,mu_init,sigma_init,pi_init,a)
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
print(Q_Value)
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
mu <- mu_update
sigma <- sigma_update
print (pi)
pi <- pi_update
theta<-c(mu, sigma, pi)
print(theta)
tvec = c(tmu, tsigma,tpi)
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.00001){
print(it)
return(theta)
}
it = it+1
}
}
mu_init <- 0
sigma_init <- 0.1
pi_init <- 0.2
a <- 20
EM(x,mu_init,sigma_init,pi_init,a)
a <- 20
mu <- 0
sigma <- 1
pi <- 0.4 # proportion de la loi normale dans le mélange
n <- 100
tirage <- sample(c(0,1), n, replace = TRUE, prob = c(pi,1-pi))
phi_sample <- rnorm(n, mean = mu , sd = sigma)
unif_sample <- runif(n, min = -a, max = a)
final_sample <- tirage*phi_sample + (1-tirage)* unif_sample
boxplot(final_sample)
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
mu <- mu_update
sigma <- sigma_update
print (pi)
pi <- pi_update
theta<-c(mu, sigma, pi)
print(theta)
tvec = c(tmu, tsigma,tpi)
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.00001){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0.1
pi_init <- 0.2
EM(x,mu_init,sigma_init,pi_init,a)
a <- 20
mu <- 0
sigma <- 1
pi <- 0.9 # proportion de la loi normale dans le mélange
n <- 100
tirage <- sample(c(0,1), n, replace = TRUE, prob = c(pi,1-pi))
phi_sample <- rnorm(n, mean = mu , sd = sigma)
unif_sample <- runif(n, min = -a, max = a)
final_sample <- tirage*phi_sample + (1-tirage)* unif_sample
boxplot(final_sample)
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
mu <- mu_update
sigma <- sigma_update
print (pi)
pi <- pi_update
theta<-c(mu, sigma, pi)
print(theta)
tvec = c(tmu, tsigma,tpi)
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.00001){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0.1
pi_init <- 0.2
EM(x,mu_init,sigma_init,pi_init,a)
final_sample <- (1-tirage)*phi_sample + (tirage)* unif_sample
boxplot(final_sample)
EM <- function(x,mu,sigma,pi,a){
it =0
repeat{
Q_Value <- Q (x,mu,sigma,pi,a)
pi_update <- mean(Q_Value)
mu_update <- sum(Q_Value*x)/sum(Q_Value)
sigma_update <- sqrt(sum((Q_Value*(x-mu_update)^2)/sum(Q_Value)))
tmu <- abs(mu_update-mu)/mu
tpi <- abs(pi_update-pi)/pi
tsigma <- abs((sigma_update-sigma)/sigma)
err <- (pi_update-pi)^2+(sigma_update-sigma)^2+(pi_update-pi)^2
mu <- mu_update
sigma <- sigma_update
print (pi)
pi <- pi_update
theta<-c(mu, sigma, pi)
print(theta)
tvec = c(tmu, tsigma,tpi)
#if (tmu <0.001 && tpi <0.001 && tsigma < 0.001){
if (err<0.00001){
print(it)
return(theta)
}
it = it+1
}
}
x<- final_sample
mu_init <- 0
sigma_init <- 0.1
EM(x,mu_init,sigma_init,pi_init,a)
knitr::opts_chunk$set(echo = TRUE)
load("/Users/Jean-Baptiste/Documents/GI05/SY19/TPs/TP6/SY19_Project2/envlouis.RData")
load("/Users/Jean-Baptiste/Documents/GI05/SY19/TPs/TP6/SY19_Project2/envJB.RData")
library(caret)
library(car)
library("e1071")
library(randomForest)
library(kernlab)
library(stats)
library(MASS)
options(Encoding="UTF-8")
plot(history)
classifieur_expressions <- function(dataset) {
# Chargement de l’environnement
load("env.Rdata",.GlobalEnv)
X <- dataset[,1:4200]
y <-dataset$y
# On sélectionne les parties expressives du visage
Xselec <- cbind(X[301:1260],X[2460:3359])
#parmi les données sélectionnées, on enlève aussi les pixels noirs
X_selpro<- Xselec[, !apply(Xselec == 0, 2, all)]
data_selpro=data.frame(X_selpro,y=y)
pred_pca <- predict(.GlobalEnv$prin_comp_pca, X_selpro)
new_data2 <-  data.frame( pred_pca[,1:25],y=y)
predictions<- predict(.GlobalEnv$classifieur_expressions, new_data2)
return(predictions)
}
classifieur_characters <- function(dataset) {
# Chargement de l’environnement
require(randomForest)
load("env.Rdata",.GlobalEnv)
predictions<- predict(.GlobalEnv$classifieur_character, dataset)
return(predictions)
}
classifieur_parole <- function(dataset) {
# Chargement de l’environnement
require('e1071')
load("env.Rdata",.GlobalEnv)
predictions<- predict(.GlobalEnv$classifieur_parole, dataset)
return(predictions)
}
source("classifieurs.R")
setwd("~/Documents/GI05/SY19/TPs/TP6/SY19_Project2")
source("classifieurs.R")
data_expressions <- read.csv("data/expressions_train.txt",sep = " ")
data_characters<- read.csv("data/characters_train.txt",sep = " ")
data_parole <- read.csv("data/parole_train.txt")
classifieur_expressions(data_expressions)
classifieur_characters(data_characters)
classifieur_parole(data_parole)
source("classifieurs.R")
cclassifieur_parole(data_parole)
View(cclassifieur_parole)
View(classifieur_characters)
View(cclassifieur_parole)
View(classifieur_characters)
classifieur_expressions(data_expressions)
View(character.test)
load("env.Rdata",.GlobalEnv)
classifieur_character_obj<- classifieur_character
classifieur_expressions_obj <-classifieur_expressions
classifieur_parole_obj <- classifieur_parole
remove(classifieur_character)
remove(classifieur_expressions)
remove(classifieur_parole)
save.image("~/Documents/GI05/SY19/TPs/TP6/SY19_Project2/env.RData")
